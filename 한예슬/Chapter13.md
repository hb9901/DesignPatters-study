## \* Chapter 13 | 렌더링 패턴

> 💡콘텐츠를 어디에서 어떻게 렌더링할 것인가?\
> 💡웹 서버, 빌드 서버, 엣지 네트워크 또는 클라이언트, 어디에서 콘텐츠를 렌더링 할 것인가?\
> 💡콘텐츠를 한 번에, 부분적으로, 또는 점진적으로 어떻게 렌더링 할 것인가?

---

뛰어난 사용자 경험을 제공하기 위해서는, `핵심 웹 지표(Core Web Vitals : CWV)` 와 같은 사용자 중심 지표를 기준으로 애플리케이션을 최적화해야 한다.

### ✔️CWV

- TTFB (Time to First Byte) : 클라이언트가 페이지 콘텐츠의 첫 번째 바이트를 받는 데 걸리는 시간
- FCP (First Contentful Paint) : 페이지 이동 후 브라우저가 콘텐츠의 첫 부분을 렌더링하는 데 걸리는 시간
- TTI (Time to Interactive) : 페이지 로드 시작부터 사용자 입력에 빠르게 응답할 수 있을 때까지 걸리는 시간
- LCP (Largest Contentful Paint) : 페이지의 주요 콘텐츠를 로드하고 렌더링 하는데 걸리는 시간
- CLS (Cumulative Layout Shift) : 예상치 못한 레이아웃 변경을 방지하기 위한 시각적 안정성 측정
- FID (First Input Delay) : 사용자가 페이지와 상호작용한 시점부터 이벤트 핸들러가 실행될 수 있는 시점까지의 시간

#### CWV 를 최적화하면 뛰어난 사용자 경험과 검색 엔진 최적화(SEO) 를 보장할 수 있다.

---

### ✔️ 클라이언트 사이드 렌더링 (CSR)

: HTML이 클라이언트에서 완전히 렌더링 된다.

- 데이터를 가져오거나 저장하기 위한 api 호출로 서버와 상호작용한다.
- 전체 웹 애플리케이션은 처음 요청시에 모두 로드된다.
- 페이지 새로고침 없이 탐색을 지원하는 SPA 를 구축할 수 있게 하여 뛰어난 사용자 경험을 제공한다.
- 뷰 변경에 사용되는 데이터가 제한적이므로 페이지 간 라우팅이 더 빠른편.
- 큰 자바스크립트 번들을 만들도록 하여 페이지의 FCP, TTI 를 증가시킨다.
- 큰 요청 객체와 api 응답과 같은 일련의 네트워크 요청으로 인해, 크롤러가 색인하기 전에 의미있는 콘텐츠가 시간에 맞춰 렌더링되지 않을 수 있음 -> SEO 에 영향을 미침

---

### ✔️ 서버 사이드 렌더링 (SSR)

: HTML 콘텐츠를 서버에서 동적으로 렌더링한 후, 클라이언트에서 하이드레이션 한다.<br>
-> `하이드레이션` : 서버 렌더링 후, 클라이언트 사이드에서 UI 컴포넌트의 상태를 재생성하는 과정.

- 모든 요청마다 HTML 을 생성한다.
  - ex) 사용자 쿠키 정보나 요청 데이터를 기반으로 하는 등, 개인 맞춤형 데이터를 포함하는 페이지, 인증 상태에 따라 렌더링 여부를 결정해야 하는 페이지

---

### ✔️ 정적 렌더링 (Static Rendering)

: 빌드 타임에 서버에서 페이지를 렌더링하여 정적인 사이트를 구축한다.

- 전체페이지의 HTML 을 빌드 시점에 미리 생성하며, 다음 빌드 때까지 변경되지 않는다.
- 정적인 HTML 콘텐츠는 CDN (Content Delivery Network) 이나 엣지 네트워크에 쉽게 캐싱될 수 있다.
  - CDN은 클라이언트가 특정 페이지를 요청하면 미리 렌더링되어 캐시된 HTML 을 빠르게 제공할 수 있으며, 일반적인 SSR 에 비해 페이지 요청을 처리하고, HTML 콘텐츠를 렌더링하고, 응답하는 데 걸리는 시간을 상당히 단축할 수 있다.
- 자주 변경되지 않고, 누가 요청하든 동일한 데이터를 표시하는 페이지에 가장 적합하다.
- 기본적으로 순수 정적 렌더링은 동적 데이터를 포함하지 않는다.

### \* 정적 렌더링의 변형

1. **`데이터베이스의 동적 데이터를 활용한 리스트 페이지 정적 생성.`**<br>
   리스트 페이지가 데이터와 함께 서버에서 생성된다. 리스트 자체가 크게 동적이지 않은 페이지에 적합하다. <br>
   -> **Page router** : page 컴포넌트 내에서 **getStaticProps()** 함수 내보내서 사용.  
   -> **App router** : fetch **cache** 옵션

2. **`동적경로(dynamic routes)를 사용한 상세 페이지 정적 생성`**<br>
   ex) 상품 페이지 / 블로그 페이지 : 보통 고정된 템플릿에 데이터를 채워넣는 방식을 따른다.<br>
   -> 템플릿과 동적 데이터를 병합하여 서버에서 개별 페이지를 생성할 수 있고, 각 상세 페이지마다 여러개의 개별 경로를 갖게된다.<br>
   -> **Page router** : **getStaticPaths()** 함수 사용.  
   -> **App router** : **generateStaticParams()** 사용

3. **`클라이언트 사이드 데이터 fetching 을 통한 정적 렌더링`**<br>
   항상 최신 목록을 표시해야 하는 동적인 리스트 페이지에 유용하다.<br>
   -> 웹사이트의 UI를 뼈대 컴포넌트와 함께 정적으로 렌더링하고, 동적 목록 데이터를 배치할 위치를 지정할 수 있다. 후에 SWR 을 사용하여 데이터를 가져온다.

> ## SWR (Stale-While-Revalidate)<br>
>
> : 클라이언트 사이드에서 데이터 fetching 을 위한 리액트 Hook 라이브러리.<br>
>
> - Vercel에서 제공하는 React용 데이터 페칭 라이브러리로, 클라이언트 사이드에서 데이터를 효율적으로 가져오고 관리하는 역할을 한다.<br>
> - 정의된 api 를 사용하여 CMS 에서 데이터를 가져와 반환한다.
> - `즉, 캐시된 데이터를 먼저 보여주고, 동시에 백그라운드에서 새로운 데이터를 가져와 업데이트 하는 전략`이다.
> - Stale-While-Revalidate 전략을 따르는데, 이는 기존 데이터를 즉시 반환한 후, 백그라운드에서 최신 데이터를 다시 가져오는 방식이다.<br>
>   이 전략 덕분에 사용자는 빠른 응답을 받으면서도 최신 데이터를 유지할 수 있다.
>
> ---
>
> ## 🎯 SWR vs React Query 비교
>
> | 기능                       | SWR                           | React Query                            |
> | -------------------------- | ----------------------------- | -------------------------------------- |
> | **데이터 페칭 방식**       | Stale-While-Revalidate        | Stale-While-Revalidate                 |
> | **API 요청 방식**          | `fetcher` 함수를 직접 정의    | `useQuery`에서 자동 요청 관리          |
> | **캐싱**                   | 자동 캐싱 & 공유              | 자동 캐싱 & 공유                       |
> | **백그라운드 데이터 갱신** | 지원                          | 지원                                   |
> | **복잡한 상태 관리**       | 미지원 (단순한 데이터 요청용) | 지원 (로딩, 에러, 데이터 상태 관리 등) |
> | **뮤테이션 (Mutate)**      | `mutate()` 사용               | `useMutation()` 사용                   |
>
> ---
>
> ✅ SWR은 가볍고 간단한 클라이언트 사이드 데이터 요청에 적합<br>
> ✅ React Query는 서버 상태를 포함한 복잡한 데이터 관리에 적합

---

### ✔️ 점진적 정적 생성 (ISR)

: 초기 빌드 이후에도 정적 사이트를 동적으로 추가하거나 수정할 수 있다.

- 정적 렌더링과 SSR을 결합한 방식.
- 특정 정적 페이지만 미리 렌더링하고 동적 페이지는 사용자 요청 시에 on-demand 방식으로 렌더링 한다.
  - 새로운 페이지 추가 허용
  - 기존 페이지 업데이트

### \* On-demand ISR

: 일반 ISR과 달리, 정해진 시간 간격이 아니라 `특정 이벤트 발생시에 페이지가 재생성`된다.

- ISR : 업데이트된 페이지가 해당 페이지에 대한 사용자 요청을 처리한 엣지 네트워크 노드에만 캐시된다.
- On-demand ISR : 엣지 네트워크 전체에 페이지를 다시 생성하고 재분배하므로, 최신 버전의 페이지를 볼 수 있다.

즉, On-demand ISR은 **특정 이벤트 발생 시 페이지를 즉시 다시 생성하는 방식**이다.<br>
기본 ISR이 일정 시간이 지나야 페이지를 업데이트하는 것과 달리(시간 기반으로 정적 페이지를 업데이트 함),<br>
On-demand ISR은 필요할 때 즉시 페이지를 갱신하는 방식이다.<br>
-> 속보, 가격 변경, 경기 점수 등 즉시 반영이 필요한 곳에 On-demand ISR 이 적합함.<br>
-> **`revalidate()`** 가 on-demand ISR 을 만드는 핵심 기능이다.

---

### ✔️ 스트리밍 SSR (Streaming SSR)

: 서버에서 렌더링 된 콘텐츠를 더 작은 스트림 조각으로 분할하여 전송한다.

- SSR 이나 정적렌더링을 사용하면 자바스크립트 용량을 줄여 페이지가 상호작용 가능해지는 시간 (TTI)을 FCP(First Contentful Paint)에 더 가깝게 만들 수 있다.
- 스트리밍 방식으로 콘텐츠를 전송하면 애플리케이션을 서버에서 렌더링하면서도 TTI와 FCP를 더욱 단축할 수 있다.
- `현재 페이지에 필요한 마크업을 모두 담은 큰 HTML 파일 하나를 생성하는 대신, 작은 조각(청크) Chunk 으로 나눠서 전송하는 것.`
- renderToNodeStream()(React 17) 또는 renderToPipeableStream()(React 18)을 사용하면 애플리케이션을 작은 조각으로 나누어 전송할 수 있다.
- 이렇게 수신된 DOM 노드에 hydrate 메서드를 호출하면 해당 이벤트 핸들러가 연결되어 UI 에 상호작용할 수 있게 된다.
- 스트리밍은 네트워크 정체현상에 효과적이다.
- `Suspense` 는 스트리밍 SSR 을 가능하게 해준다. 즉, Streaming SSR은 HTML을 나눠서 보내지만, Suspense가 있어야 UI를 자연스럽게 채울 수 있음

---

### ✔️ 엣지 렌더링 (Edge Rendering)

: 렌더링된 HTML을 클라이언트에 전송하기 전에 엣지에서 수정한다.

- **서버에서 렌더링된 HTML을 클라이언트에 전송하기 전에 엣지 서버에서 수정 및 최적화하는 방식**.
- 사용자와 가까운 엣지 서버에서 실행되므로 **지연 시간(콜드부트트)을 줄이고, 성능을 극대화**할 수 있음.
- 네트워크 경로가 짧아 **빠른 응답이 필요한 개인화된 콘텐츠(예: 지역 기반 추천, 인증된 사용자 정보 표시)**에 적합.
- **데이터 요청이 발생할 때마다 새로운 HTML을 생성하는 방식과 다르게, 캐시된 HTML을 업데이트하면서 빠른 반응성을 제공**할 수 있음.

---

### ✔️ 하이브리드 렌더링 (Hybrid Rendering)

: 빌드 타임, 서버 및 클라이언트 렌더링을 결합하여 웹 개발에 더 유연한 접근 방식을 제공한다.<br>
-> ex) 리액트 서버 컴포넌트 / Next.js App router

- **빌드 타임(static), 서버(server-side), 클라이언트(client-side) 렌더링을 조합하여 성능과 유연성을 동시에 확보하는 방식**.
- 서버 렌더링(SSR)과 정적 사이트 생성(SSG)을 혼합하여 사용하여, 성능 최적화를 극대화하면서도 동적 데이터를 반영할 수 있음.
- 특정 페이지는 빌드 시 생성하고, 특정 페이지는 서버에서 동적으로 렌더링하여 **요구 사항에 맞는 최적의 방식으로 조합 가능**.
- **동적 데이터를 실시간 반영하면서도 초기 로딩 속도를 높이고 싶은 경우에 유용함**.

---

### ✔️ 부분 하이드레이션 (Partial Hydration)

: 클라이언트에서 일부 컴포넌트만 하이드레이션 한다.<br>
-> ex) 리액트 서버 컴포넌트 / Gatsby

- **전체 페이지가 아닌, 특정 동적 요소만 클라이언트에서 활성화하여 하이드레이션하는 방식**.
- 서버에서 렌더링된 HTML을 먼저 제공하고, 필요한 부분만 클라이언트에서 활성화하여 성능을 향상시킴.
- 페이지의 정적 콘텐츠는 즉시 표시되며, 동적 인터랙션이 필요한 요소는 이후 점진적으로 하이드레이션됨.
- **불필요한 클라이언트 렌더링을 최소화하여 성능과 초기 로딩 속도를 개선할 수 있음**.

---

### ✔️ 점진적 하이드레이션 (Progressive Hydration)

: 클라이언트에서 컴포넌트 하이드레이션 순서를 제어한다.

- **전체 페이지를 한꺼번에 하이드레이션하는 대신, 중요한 요소부터 순차적으로 하이드레이션하여 사용자 경험을 향상하는 방식**.
- 페이지의 중요한 콘텐츠(예: 네비게이션 바, 주요 텍스트 등)를 먼저 활성화하고, 나머지는 사용자가 상호작용할 때 점진적으로 활성화됨.
- 초기 렌더링이 빨라지고, 필요할 때만 동적 요소가 실행되므로 **CPU 및 메모리 사용량을 줄일 수 있음**.
- **저사양 기기에서도 원활한 사용자 경험을 제공하며, 브라우저가 처리해야 할 부담을 줄일 수 있음**.

---

### ✔️ 아일랜드 아키텍쳐 (Islands Architecture)

: 정적인 사이트 내에 여러 진입점을 가진 동적인 동작의 격리된 영역을 만든다.

- **전체 페이지를 단일 애플리케이션처럼 렌더링하는 대신, 독립적인 동적 블록(아일랜드)을 생성하여 관리하는 방식**.
- 정적 콘텐츠와 동적 콘텐츠를 구분하여, 필요한 영역만 동적으로 업데이트하여 렌더링 성능을 개선함.
- 특정 컴포넌트만 동작하도록 하여, **페이지 내에서 독립적으로 동작하는 동적 영역을 효율적으로 배치할 수 있음**.
- 전체 페이지를 클라이언트에서 재렌더링하는 비용을 줄이고, **최소한의 리소스로 최대한의 인터랙션을 제공**.

---

### ✔️ 점진적 향상 (Progressive Enhancement)

: 자바스크립트 없이도 애플리케이션이 적용하도록 보장한다.

- **자바스크립트가 비활성화된 환경에서도 기본적인 기능이 동작하도록 보장하는 개발 접근 방식**.
- 핵심 기능은 HTML과 CSS만으로 구현하고, 추가적인 기능 향상을 위해 자바스크립트를 사용하여 개선함.
- 모든 환경에서 기본적인 접근이 가능하도록 보장하면서도, 자바스크립트를 지원하는 환경에서는 풍부한 사용자 경험을 제공할 수 있음.
- **웹 접근성을 보장하면서도, 기능 향상을 통해 최상의 사용자 경험을 제공하는 것이 목표**.
