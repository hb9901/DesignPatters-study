## \* Chapter 2 | 패턴성 검증, 프로토 패턴, 세 가지 법칙

### ✔️ 프로토 패턴 (Proto Pattern) 이란?

#### : 패턴성 검증을 모두 통과하지 않은 미숙한 패턴.

즉, 완전히 정립되지 않았거나 아직 널리 사용되지 않았지만 실무에서 특정 문제를 해결하는 데 잠재적으로 유용한 패턴을 뜻한다.<br>
디자인 패턴의 정형화된 정의를 가지지 않았기 때문에 "프로토(Proto)" 라는 이름이 붙은 것이며, 이는 곧 정식 패턴으로 발전할 가능성을 가지고 있다.

### ✔️ 패틀릿 (Patternlet)

#### : 아주 작은 규모의 디자인 패턴

일반적인 디자인 패턴처럼 큰 구조를 제공하지 않고, 그보다는 작은 문제를 해결하는 미니패턴

#### \* 특징

- 매우 단순하고 좁은 범위의 문제를 해결한다.
- 더 큰 디자인 패턴의 일부로 사용될 수 있으며, 이를 구성하는 작은 구성요소 역할을 한다.
- 문제를 해결하는 미세한 패턴으로, 일반적으로 하나의 간단한 목적에 집중한다.

### ✔️ 세 가지 법칙

좋은 패턴이 되기 위해서는 반복되는 현상/문제에서 지속적으로 사용되어야 한다.
반복성을 입증하려면 세가지 법칙이라고 불리는 아래의 질문에 답할 수 있어야 한다.

1. `목적 적합성`<br>
   : 좋은 패턴은 어떻게 판단하나요?

2. `유용성`<br>
   : 좋은 패턴이라고 할 수 있는 이유가 무엇인가요?

3. `적용 가능성`<br>
   : 넓은 적용 범위를 가지고 있어 패턴이 될 가치가 있나요? 만약 그렇다면 왜 그런지 설명해야 한다.

---

## \* Chapter 3 | 패턴 구조화 및 작성 (좋은패턴)

### ✔️ 디자인 패턴의 구조

#### 패턴의 작성자는 패턴의 설계, 구현방법 및 목적을 설명해야 한다.

아래의 관계성을 생각해, **규칙의 형태로 패턴을 제시한다.**

- `컨텍스트 (Context)` : 패턴이 적용되는 상황
- `집중 목표 (System of Forces)` : 패턴을 적용할때 고려해야 하는 목표
- `구성 (Configuration)` : 제시된 상황과 고려해야 하는 점들을 해결하는 구성

#### \* 디자인 패턴의 구성요소

- 이름 : 패턴의 목적을 드러내야함
- 설명 : 패턴이 무엇을 해결할 수 있는지에 대한 간단한 설명
- 컨텍스트 개요 : 패턴이 사용자의 요구에 부합하는지에 대한 설명
- 문제 제시 : 패턴을 만든 의도를 알 수 있도록 문제를 제시
- 해결 방법 : 이해하기 쉬운 단계와 개념을 통해 문제가 어떻게 해결되는지에 대한 설명

---

- 설계 내용 : 패턴의 설계와 사용자가 어떻게 사용할 수 있는지에 대한 설명
- 구현 방법 : 패턴을 구현하는 방법에 대한 지침
- 시각적 설명 : 다이어그램처럼 패턴을 나타내는 시각적 설명이 있어야함
- 예제 : 패턴을 구현한 예시
- 필수 연계 : 해당 패턴과 함께 사용하면 좋은 패턴에 대한 내용
- 관계성 : 다른 패턴과의 관계 및 유사점에 대한 내용
- 알려진 용도 : 업계에서 이미 쓰이던 패턴인지에 대한 설명
- 토론 : 해당 패턴의 이점에 대한 사람들의 의견

---

## \* Chapter 4 | 안티패턴 (잘못된 패턴)

### ✔️ 안티패턴이란?

#### : 겉으로만 해결책처럼 생긴 패턴

- 문제 상황에 대한 잘못된 해결책
- 문제 상황에서 벗어나 올바른 해결책에 이르는 방법

### ✔️ 자바스크립트 안티 패턴

- 전역 컨텍스트에서 수많은 변수를 정의하여 전역 네임스페이스를 오염시키기
- setTimeout 이나 setInterval 에 함수가 아닌 문자열을 전달해서 내부적으로 eval() 실행되게 하기

  - 안티패턴인 이유 : 보안, 성능, 디버깅의 어려움, 가독성 저하 문제
  - eval() 함수는 전달된 문자열을 자바스크립트 코드로 실행한다.
    문자열로 실행되는 코드는 외부 입력에 의존할 경우 보안상 매우 취약할 수 있다.

  ```js
  setTimeout("alert('hello')", 1000); // eval을 통해 문자열 실행

  // 따라서 함수를 직접 전달하는것이 좋다
  setTimeout(() => {
    alert("hello");
  }, 1000);
  ```

- Object 클래스의 프로토타입을 수정하기 (특히 나쁜 안티 패턴)

  - 안티패턴인 이유 : 모든 객체에 영향을 줌, 예기치 않은 부작용
  - 프로토타입 체인 개념.
    - 자바스크립트에서 모든 객체는 프로토타입 체인을 통해 상속을 받는다.
    - 즉, 객체는 자신에게 없는 메서드나 속성을 프로토타입 체인 상위에 있는 객체에서 찾게 된다.
    - 모든 객체는 기본적으로 Pbject.prototype 을 프로토타입으로 상속받기 때문에, Object.prototype 에 정의된 메서드는 모든 객체에서 접근할 수 있다.

  ```js
  Object.prototype.newMethod = function () {
    console.log("모든 객체에서 사용 가능");
  };

  const obj1 = {};
  const obj2 = {};

  obj1.newMethod(); // 정상 동작
  obj2.newMethod(); // 정상 동작

  for (let key in obj1) {
    console.log(key); // newMethod가 포함됨
  }
  ```

  - Object.prototype에 추가된 newMethod() 함수가 obj1과 obj2 객체에서 호출될 수 있다. (자신의 메서드처럼 호출할 수 있음)
  - for...in은 자체 속성뿐만 아니라 프로토타입 체인에서 상속받은 열거 가능한(enumerable) 속성까지 순회

- 자바스크립트를 인라인으로 사용하여 유연성을 떨어뜨리기
  ```js
  <button onclick="alert('클릭했습니다!')">클릭</button>
  ```
- document.createElement 대신 document.write 사용하기<br>
  document.write 는 오랫동안 잘못 사용되어 왔으며, 여러 단점을 가지고 있다. 만약 페이지가 로드된 뒤에 실행된다면 기존 페이지의 내용을 덮어씌우기 때문에 document.createElement 가 더 적합하다. 또한 XHTML 에서는 작동하지 않기때문에 document.createElement 같은 DOM 친화적인 메서드를 사용하는 것이 좋다.

  ```js
  document.write("<h1>Hello, World!</h1>");

  // createElement 사용
  const newElement = document.createElement("h1");
  newElement.textContent = "Hello, World!";
  document.body.appendChild(newElement);
  ```
