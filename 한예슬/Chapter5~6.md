## \* Chapter 5 | 최신 자바스크립트 문법과 기능

### ✔️ 애플리케이션 분리의 중요성

- 모듈형인 자바스크립트는 애플리케이션을 `모듈`이라는 단위로 쪼갤 수 있다.
- 모듈은 다른 모듈을 가져올 수 있으며, 이 모듈이 또 다른 모듈을 가져올 수도 있다.
- 즉, 애플리케이션은 여러개의 중첩된 모듈로 구성될 수 있다.

---

### ✔️ 모듈 가져오기와 내보내기

- 모듈을 사용하면 각 기능에 맞는 독립적인 단위로 코드를 분리할 수 있다.
- 모듈형 언어가 되기 위해서는 의존성을 가진 모듈을 `가져오고(import)` `내보낼(export)` 수 있어야 한다.
  - import 문을 이용하면 내보내기된 모듈을 지역 변수로 가져올 수 있으며, 기존 변수명과의 충돌을 피하고자 이름을 바꿔서 가져올 수도 있다.
  - export 문을 이용하면 지역 모듈을 외부에서 읽을 수 있지만, 수정할 수는 없도록 만들어준다.
    - 직속 하의 모듈은 내보낼 수 있지만, 다른 외부에서 정의된 모듈은 내보낼 수 없다. 또한 import 문처럼 이름을 바꿔 내보낼 수 있다.
- 일반적으로 모듈 파일은 여러 함수, 상수 및 변수를 가지고 있다. 파일 끝부분에서 내보내고 싶은 모듈을 객체로 정리하여 하나의 export문으로 단번에 내보낼 수 있다.
- 사용할 모듈만을 가져오는 것도 가능하다.
- `<script>` 태그에서 `type`에 모듈을 명시하여 브라우저에게 알릴 수 있다.
- `nomodule` 속성은 브라우저에 모듈이 아님을 알려준다.

```jsx
<script type="module" src="main.mjs"></script>
<script nomodule src="fallback.js"></script>
```

---

### ✔️ 모듈 객체

- 모듈을 객체로 가져오면 모듈 리소스를 깔끔하게 가져올 수 있다.
- 객체 하나만으로 여러 곳에 사용할 수 있다.

```jsx
import * as Staff from "/modules/staff/mjs";

export const oven = {
  makeCupcake(toppings) {
    Staff.baker.bake("cupcake", toppings);
  },
  makePastry(mSize) {
    Staff.pastryChef.make("Pastry", type);
  },
};
```

---

### ✔️ 외부 소스로부터 가져오는 모듈

- 외부 소스에서 가져오는 원격 모듈 (ex. 서드파티 라이브러리) 을 쉽게 가져올 수 있게 되었다.

```jsx
import { cakeFactory } from "http://example.com/modules/cakeFactory.mjs";
// 미리 로드된 정적 가져오기

cakeFactory.oven.makeCupcake("sprinkles");
cakeFactory.oven.makeMuffin("large");
```

---

### ✔️ 정적으로 모듈 가져오기

- 위의 방법들은 모두 정적 가져오기이다.
- 메인코드를 실행하기 전에 먼저 모듈을 다운로드하고 실행해야 한다.
- 초기 페이지 로드 시 많은 코드를 미리 로드해야 하므로, 성능에 문제가 생길 수 있다.

---

### ✔️ 동적으로 모듈 가져오기

- 모듈을 필요한 시점에만 로드하는 것이 더 이로울 때가 있다.
- 지연 로딩(lazy-loading) 모듈을 사용하면 필요한 시점에 로드할 수 있다.
  ex) 사용자가 링크나 버튼을 클릭할 때 로드하게 만들 수 있음. -> 초기 로딩 시간을 줄일 수 있다.
- `동적 가져오기 (dynamic import)`는 함수와 비슷한 새로운 형태의 가져오기이다.
  - import(url) 는 요청된 모듈의 네임스페이스 객체에 대한 프로미스 객체를 반환한다. 이 프로미스 객체는 모듈 자체와 모든 모듈 의존성을 가져온 후, 인스턴스화하고 평가한 뒤에 만들어진다.
  - await 과 함께 사용할 수 있다.
  - 동적 가져오기를 사용하면 모듈이 사용될 때만 다운로드되고 실행된다.
  - 사용자 상호작용에 반응하거나 화면에 보이면 실행하기 등 자주 사용되는 패턴은 동적 가져오기를 통해 바닐라 자바스크립트에서도 쉽게 구현할 수 있다.

```jsx
form.addEventListener("submit", (e) => {
  e.preventDefault();
  import("/modules/cakeFactory.js").then((module) => {
    //가져온 모듈 사용하기
    module.oven.makeCupcake("sprinkles");
    module.oven.makeMuffin("large");
  });
});

// await 과 함께 사용
let module = await import("/modules/cakeFactory.js");
```

---

### ✔️ 사용자 상호작용에 따라 가져오기

- ex) 채팅창, 다이얼로그, 비디오
- `lodash.sortby` 모듈을 동적으로 로드하여 정렬 기능을 구현하는 코드

```jsx
const btn = document.querySelector("button");

btn.addEventListener("click", (e) => {
  e.preventDefault();
  import("lodash.sortby")
    .then((module) => module.default)
    .then(sortInput()) // use the imported dependency
    .catch((err) => {
      console.log(err);
    });
});
```

---

### ✔️ 화면에 보이면 가져오기

- `intersectionObserver API` 사용 -> 컴포넌트가 화면에 보이는지 감지할 수 있음
  -> 이에따라 모듈을 동적으로 로드가능능
- ex) 무한스크롤

---

### ✔️ 서버에서 모듈 사용하기

- Node는 type 이 module 이라면 .mjs와 .js 로 끝나는 파일을 자바스크립트 모듈로 취급한다.

---

### ✔️ 모듈을 사용하면 생기는 이점

#### `1. 한 번만 실행된다.`</br>

-> 기존 스크립트는 DOM에 추가될 때마다 실행되는 반면에 모듈 스크립트는 한 번만 실행된다.
자바스크립트 모듈을 사용하면 의존성 트리의 가장 내부에 위치한 모듈이 먼저 실행된다.
가장 내부에 위치한 모듈이 먼저 평가되고 여기에 의존하는 모듈에 접근 할 수 있다는 점이 이점이다.

#### `2. 자동으로 지연 로드된다.`</br>

-> 즉시 로드되지 않기 위해 다른 스크립트 파일은 defer 속성을 붙여야 하지만, 모듈은 자동으로 지연되어 로드된다.

#### `3. 유지보수와 재사용이 쉽다.` </br>

-> 다른 모듈에 영향을 주지 않고 독립적으로 실행될 수 있는 코드 조각으로 관리된다.

#### `4. 네임스페이스를 제공한다.` </br>

-> 관련 변수와 상수를 위한 개별 공간을 생성하여 글로벌 네임스페이스를 오염시키지 않고 모듈 참조를 통해 사용할 수 있게 해준다.

#### `5. 사용하지 않는 코드를 제거한다.` </br>

-> 웹팩이나 롤업 같은 번들러를 사용해 사용하지 않는 모듈을 자동으로 제거할 수 있다.</br>
-> 이처럼 `번들에 추가하기 전에 사용하지 않는 코드를 제거하는 것`을 **트리쉐이킹 (tree-shaking)** 이라고 한다.

---

### ✔️ 생성자, 게터, 세터를 가진 클래스 (class)

- 생성자와 내부를 숨기는 기능을 가진 클래스(class) 가 추가되었다.
- function 단어의 남용을 줄이려고 노력했음
- `class` 키워드를 통해 사용할 수 있다.
- `프로토타입`을 기반으로 하고 있으며, 사용하기 전에 미리 정의해야만 한다.
- `extends` 키워드를 통해 클래스를 상속받을 수도 있다.
- 부모 클래스의 생성자를 실행할 수 있는 `super` 키워드를 지원원
- 모듈과 클래스의 차이점은 모듈은 가져오기/내보내기를 통해, 클래스는 class 키워드를 통해 정의할 수 있다는 점이다.
- 클래스 내부 멤버를 비공개로 정의할 수 있다.
- 공개 클래스 멤버는 다른 클래스도 사용할 수 있지만, 비공개 클래스 멤버는 선언된 클래스 내부에서만 사용할 수 있다. 클래스 멤버는 기본적으로 공개 상태이며, `# (해시)` 를 앞에 붙여 비공개 멤버로 만들 수 있다.
- `static` 키워드를 통해 정적 메서드와 프로퍼티를 정의할 수 있다. 정적 멤버는 클래스를 초기화하지 않고도 사용할 수 있다. 주로 어떠한 설정이나 캐시 데이터를 보관하기 위해 사용된다.

```jsx
class Cake {
  // 생성자 안에서 변수를 정의한다.
  constructor(name, toppings, price, cakeSize) {
    this.name = name;
    this.cakeSize = cakeSize;
    this.toppings = toppings;
    this.price = price;
  }

  // ES2015 버전 이상에서는 모든 것을 함수로 만드는 것을 피하고자
  // 새로운 식별자를 사용하려고 했다.

  addTopping(topping) {
    this.toppings.push(topping);
  }

  // 게터는 메서드 이름 앞에 넣어 사용한다.
  get allToppings() {
    return this.toppings;
  }

  get qualifiesForDiscount() {
    return this.price > 5;
  }

  // 세터도 메서드 이름 앞에 넣어 사용한다.
  set size(size) {
    if (size < 0) {
      throw new Error("~error message");
    }
    this.cakeSize = size;
  }
}

// 사용방법
let cake = new Cake("chocolate", ["chocolate chips"], 5, "large");

// extends 상속
class BirthdayCake extends Cake {
  surprise() {
    console.log("생일축하해!");
  }
}

let birthdayCake = new BirthdayCake(
  "chocolate",
  ["chocolate chips"],
  5,
  "large"
);
birthdayCake.surprise();

// super 부모 클래스의 메서드 실행
class Cookie {
  constructor(flavor) {
    this.flavor = flavor;
  }

  showTitle() {
    console.log("the flavor of this cookie is ${this.flavor}");
  }
}

class FavoriteCookie extends Cookie {
  showTitle() {
    super.showTitle();
    console.log(`${this.flavor} is amazing`);
  }
}

let myCookie = new FavoriteCookie("chocolate");
myCookie.showTitle();

// 출력: the flavor of this cookie is chocolate
// 출력: chocolate is amazing

// # 비공개 멤버
class CookieWithPrivateField {
  #privateField;
}

class CookieWithPrivateMethod {
  #privateMethod() {
    return "delicious cookies";
  }
}

// static

class Cookie {
  constructor(flavor) {
    this.flavor = flavor;
  }
  static brandName = "Best Bakes";
  static discountPercent = 5;
}
console.log(Cookie.brandName);
//"Best Bakes" 출력력
```

---

### ✔️ 자바스크립트 프레임워크와 클래스

- 리액트와 같은 최신 자바스크립트 라이브러리와 프레임워크는 클래스의 대체제를 도입해 왔다.
- 대표적으로 리액트 Hooks 는 클래스를 사용하지 않고도 리액트의 상태와 라이프 사이클을 다룰 수 있도록 만들어졌다.
- 클래스는 웹 컴포넌트같은 다양한 시도로 개발과정에서 클래스 기반으로 이루어지고 있다.

---

## \* Chapter 6 | 디자인 패턴의 유형

- 디자인 패턴의 세 가지 주요 유형과 각 유형에 속하는 다양한 패턴들을 살펴보자.
- 디자인 패턴은 모두 특정 객체 지향 설계의 문제나 이슈를 다룬다.
- 문제를 해결하는 방법에 있어, 패턴 간에 서로 어떤 공통점을 가졌는지 찾아보고 이를 기준으로 디자인 패턴의 유형을 분류해보자

---

### ✔️ 배경

- 디자인 패턴은 공통 설계 구조의 핵심 요소를 이름 짓고 추상화하여 재사용할 수 있는 객체 지향 설계를 만드는 데 유용한 역할을 한다.
- 유용한 클래스와 인스턴스를 제공하여 각각의 역할과 협업, 책임의 분배를 실현한다.
- 모든 디자인 패턴은 특정 객체 지향 설계의 문제나 이슈에 초점을 맞춘다.
- 어디에 적용될 수 있는지, 다른 설계 조건에도 부합하는지, 사용함으로써 얻는 장단점과 결과를 설명한다.
- 디자인 패턴은 `어떤 문제를 해결하느냐`에 따라 다음 세 가지 유형으로 분류된다.
  - 생성 패턴
  - 구조 패턴
  - 행위 패턴

---

### ✔️ 생성 패턴

- 주어진 상황에 적합한 객체를 생성하는 방법에 중점을 둔다.
- 기본적인 객체 생성 방식은 프로젝트의 복잡성을 증가시킬 수도 있기에, 생성 패턴은 이 과정을 제어하여 문제를 해결하는 것을 목표로 한다.
  - 생성자, 팩토리, 추상, 프로토타입, 싱글톤, 빌더 패턴이 생성 패턴에 속한다.

---

### ✔️ 구조 패턴

- 객체의 구성과 각 객체 간의 관계를 인식하는 방법에 중점을 둔다.
- 시스템의 어느 한 부분이 변경되더라도 다른 부분에는 영향이 가지 않도록 도와주며, 설계 목적에 맞지 않는 부분을 개선하는 데에도 도움이 된다.
  - 데코레이터, 파사드, 플라이웨이트, 어댑터, 프록시 패턴이 구조 패턴에 속한다.

---

### ✔️ 행위 패턴

- 시스템 내의 객체 간 커뮤니케이션을 개선하거나 간소화하는 방법에 중점을 둔다.
- 객체 간의 공통적인 커뮤니케이션 패턴을 감지하고 책임을 분배함으로써 커뮤니케이션의 유연성을 높이고, 객체의 행위를 추상화한다.
  - 이터레이터, 중재자, 관찰자, 방문자 패턴이 행위 패턴에 속한다.

---

### ✔️ 디자인 패턴의 분류

> #### 생성 패턴 (Creational Patterns)

| 패턴                               | 객체 생성의 기반이 되는 개념                                            |
| ---------------------------------- | ----------------------------------------------------------------------- |
| **팩토리 메서드 (Factory Method)** | 인터페이스를 기반으로 여러 파생 클래스를 생성                           |
| **추상 팩토리 (Abstract Factory)** | 구체적인 내부 구현 없이 여러 클래스가 상속받아 사용하는 인스턴스를 생성 |
| **빌더 (Builder)**                 | 객체를 생성하는 부분과 내부 구현을 분리하여 항상 같은 객체를 생성       |
| **프로토타입 (Prototype)**         | 복사 또는 복제에 사용되는 초기화된 인스턴스                             |
| **싱글톤 (Singleton)**             | 전역에서 접근 가능한 하나만의 인스턴스를 가진 클래스                    |

</br>

---

</br>

> #### 구조 패턴 (Structural Patterns)

| 패턴                         | 객체 구조의 기반이 되는 개념                                 |
| ---------------------------- | ------------------------------------------------------------ |
| **어댑터 (Adapter)**         | 호환되지 않는 인터페이스가 상호작용하도록 클래스를 매칭      |
| **브릿지 (Bridge)**          | 객체의 인터페이스와 구현을 분리하여 독립적으로 구성          |
| **컴포지트 (Composite)**     | 단순히 합친 상태 이상의 효율을 내는 간단하면서 복합적인 구조 |
| **데코레이터 (Decorator)**   | 객체에 새로운 프로세스를 동적으로 추가                       |
| **파사드 (Facade)**          | 전체 시스템의 복잡한 부분을 숨기는 단일 클래스               |
| **플라이웨이트 (Flyweight)** | 여러 객체에 공통 상태를 공유하는 세분화된 인스턴스           |
| **프록시 (Proxy)**           | 실제 객체를 대신하는 대체 객체                               |

</br>

---

</br>

> #### 행위 패턴 (Behavioral Patterns)

| 패턴                                    | 객체 상호작용의 기반이 되는 개념                                                    |
| --------------------------------------- | ----------------------------------------------------------------------------------- |
| **인터프리터 (Interpreter)**            | 언어의 복잡한 문법에 일치하는 언어 요소를 포함시키는 방법                           |
| **템플릿 메서드 (Template Method)**     | 상위 클래스에서 기본 구조를 생성한 다음 하위 클래스에서 구체적으로 정의             |
| **책임 연쇄 (Chain of Responsibility)** | 요청을 처리할 수 있는 객체를 찾기 위해 체인 간에 요청을 전달                        |
| **커맨드 (Command)**                    | 호출 부분과 실행 부분을 나누는 방법                                                 |
| **이터레이터 (Iterator)**               | 내부 구조를 모른 채 요소에 순차적으로 접근                                          |
| **중재자 (Mediator)**                   | 클래스가 서로를 직접적으로 참조하지 않도록 중재 객체가 간소화된 커뮤니케이션을 정의 |
| **메멘토 (Memento)**                    | 나중에 복구할 수 있도록 객체의 내부 상태를 저장                                     |
| **관찰자 (Observer)**                   | 클래스 간의 일관성을 보장하기 위해 여러 클래스에 변경사항을 알리는 방법             |
| **상태 (State)**                        | 상태가 변경되면 객체의 행위도 변경                                                  |
| **전략 (Strategy)**                     | 클래스 내부의 알고리즘 구현을 캡슐화하여 상황에 따른 선택과 구현을 분리             |
| **방문자 (Visitor)**                    | 클래스를 변경하지 않고 새로운 작업을 추가                                           |

## </br>

### 💭 이런 패턴들을 실무 프로젝트에서 적용할 때 가장 먼저 고려해야 할 것은 무엇일까?

- `프로젝트의 요구사항과 복잡성`
- `패턴이 해결하려는 문제와 목적`

  - 예를 들어, 객체 생성이 자주 발생하고 유연성을 확보해야 한다면 팩토리 패턴이 적절함.<br>
    동일한 객체를 공유하고 싶다면 싱글톤 패턴, 객체 구성을 동적으로 변경하고 싶다면 데코레이터 패턴이 유용함.

- `코드의 유연성과 재사용성`
  - 전략 패턴(Strategy Pattern)을 활용하면 알고리즘을 쉽게 교체할 수 있어 유연성이 증가함.<br>
  - 빌더 패턴(Builder Pattern)을 사용하면 복잡한 객체 생성을 단순화할 수 있어 재사용성이 높아짐.

---

### 💭 생성 패턴과 구조 패턴을 함께 사용할 수 있는 시나리오는 어떤 것들이 있을까?

생성 패턴과 구조 패턴은 상호보완적인 역할을 할 수 있으며, 실무에서는 함께 활용되는 경우가 많다.<br>
대표적인 시나리오는 다음과 같다.

1. `팩토리 패턴 + 프록시 패턴`
   객체 생성을 팩토리 패턴으로 캡슐화하고, 프록시 패턴을 이용해 실제 객체 대신 가벼운 프록시 객체를 반환.

- 예제: 데이터베이스 연결 객체를 팩토리 패턴으로 생성하고, 프록시 패턴을 사용해 연결을 지연 초기화(Lazy Initialization)하는 방식.

2. `빌더 패턴 + 데코레이터 패턴`
   빌더 패턴을 사용해 객체를 생성한 후, 데코레이터 패턴을 적용하여 객체의 기능을 동적으로 확장.

- 예제: 주문서(Order) 객체를 빌더 패턴으로 생성한 후, 데코레이터 패턴을 적용해 쿠폰 할인, 멤버십 할인 등의 추가 기능을 부여.

3. `추상 팩토리 패턴 + 브릿지 패턴`
   추상 팩토리 패턴을 이용해 여러 플랫폼(예: Windows, macOS, Linux)에 맞는 UI 컴포넌트를 생성.
   브릿지 패턴을 사용하여 UI의 추상화 계층과 구현 계층을 분리.

- 예제: 크로스 플랫폼 애플리케이션에서 GUI 요소를 생성하는 UI 라이브러리.

4. `싱글톤 패턴 + 플라이웨이트 패턴`
   싱글톤 패턴을 활용해 한 개의 공유 객체를 유지하고, 플라이웨이트 패턴을 통해 메모리를 절약.

- 예제: 폰트 렌더링 시스템에서 동일한 글꼴 객체를 공유하여 메모리 사용을 최소화.

---

### 💭 행동 패턴 중에서 프로젝트 유지보수에 큰 도움이 될 수 있는 패턴은 무엇이고, 그 이유는 무엇일까?

1. #### `옵저버 패턴 (Observer Pattern)`

- 한 객체의 상태 변화가 여러 객체에 영향을 미칠 경우, 옵저버 패턴을 사용하면 변경 사항이 자동으로 전파됨.
  - 이벤트 리스너(Listener) 시스템, 알림(Notification) 시스템, 실시간 UI 업데이트.
  - 프론트엔드에서는 React의 useEffect와 상태 관리 라이브러리(Redux, Zustand)에서 많이 사용됨.
  - 백엔드에서는 WebSocket 기반의 실시간 데이터 업데이트에 활용.

2. #### `전략 패턴 (Strategy Pattern)`

- 특정 로직(알고리즘)을 독립적인 클래스로 분리하여 쉽게 교체 가능.
- 코드 수정 없이 새로운 전략을 추가할 수 있어 확장성이 뛰어남.
  - 결제 시스템에서 다양한 결제 수단(카드, 계좌이체, 포인트)을 관리할 때 사용.
  - AI 추천 시스템에서 여러 추천 알고리즘을 변경할 때 활용.

3. #### `책임 연쇄 패턴 (Chain of Responsibility Pattern)`

- 요청 처리 로직을 여러 객체에 분산시켜 코드의 결합도를 낮출 수 있음.
  새로운 처리 단계를 쉽게 추가하거나 제거할 수 있음.
  - HTTP 요청 처리 미들웨어 (Express.js, NestJS).
  - 인증 및 권한 부여 시스템 (예: JWT 토큰 검증 → 역할(Role) 확인 → 요청 실행).

4. #### `커맨드 패턴 (Command Pattern)`

- 명령을 객체로 캡슐화하여 실행 취소(Undo) 기능을 쉽게 구현할 수 있음.
- 요청을 큐에 저장하여 나중에 실행할 수도 있음.
  - 에디터의 실행 취소(Undo)/다시 실행(Redo) 기능
  - 매크로 시스템(자동화 기능 구현).
