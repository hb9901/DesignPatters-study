
## 렌더링 패턴의 중요성 

- 주어진 상황에 가장 적합한 렌더링 패턴을 선택하는 것은 개발 팀을 위한 개발 경험과 최종 사용자를 위한 사용자 경험에 엄청난 차이를 만들 수 있습니다.

### 핵심 웹 지표(CWV)

|핵심 웹 지표|설명|
|:---:|:---:|
|TTFB|클라이언트가 페이지 콘텐츠의 첫 번째 바이트를 받는 데 걸리는 시간|
|FCP|페이지 이동 후 브라우저가 콘텐츠의 첫 부분을 렌더링하는 데 걸리는 시간|
|TTI|페이지 로드 시작부터 사용자 입력에 빠르게 응답할 수 있을 때까지 걸리는 시간|
|LCP|페이지의 주요 콘텐츠를 로드하고 렌더링하는 데 걸리는 시간|
|CLS|예상치 못한 레이아웃 변경을 방지하기 위한 시각적 안정성 측정|
|FID|사용자가 페이지와 상호작용한 시점부터 이벤트 핸들러가 실행될 수 있는 시점까지의 시간|

- CWV를 최적화하면 핵심 웹 지표를 개선할 수 있습니다.
- CWV를 최적화하면 `사용자 경험`과 `검색 엔진 최적화(SEO)`를 보장할 수 있습니다.

### 개발 환경 최적화

|개발 환경 최적화 종류|설명|
|:---:|:---:|
|빠른 빌드 시간|빠른 반복작업과 배포를 위햐 프로젝트는 빠르게 빌드되어야 합니다.|
|낮은 서버 비용|웹사이트는 서버 실행 시간을 제한하고 최적화하여 비용을 절감해햐 합니다.|
|동적 콘텐츠|페이지는 동적 콘텐츠를 효율적으로 로드할 수 있어야 합니다.|
|쉬운 롤백|이전 빌드 버전으로 빠르게 되돌리고 배포할 수 있어야 합니다.|
|안정적인 가동 시간|운영 서버를 통해 사용자가 항상 웹사이트에 접속할 수 있어야 합니다.|
|확장 가능한 인프라|성능 문제없이 프로젝트를 확장 또는 축소할 수 있어야 합니다.|


## 클라이언트 사이드 렌더링(CSR)

- 대부분의 애플리케이션 로직이 클라이언트에서 실행되며, 데이터를 가져오거나 저장하기 위한 API 호출로 서버와 상호작용합니다.
- 따라서 거의 모든 UI가 클라이언트에서 생성되며, 전체 웹 어플리케이션은 처음 요청 시에 모두 로드됩니다.

### 특징(장점)
- 페이지 새로고침 없이 탐색을 지원하는 SPA를 구축할 수 있게 하여 뛰어난 사용자 경험을 제공합니다.
- 뷰 변경에 사용되는 데이터가 제한적이므로 페이지 간 라우팅이 더 빠른 편입니다.

### 특징(단점)
- 페이지의 복잡성이 증가하면 큰 자바스크립트 번들을 만들도록 하여 페이지의 FCP와 TTI를 증가시킵니다.
- 또한 큰 요청 객체와 API 응답과 같은 일련의 네트워크 요청으로 인해, 크롤러가 색인하기 전에 의미 있는 콘텐츠가 시간에 맞춰 렌더링 되지 않을 수 있어 웹사이트의 SEO에 영향을 미칠 수 있습니다.

## 서버 사이드 렌더링(SSR)

- SSR은 사용자 요청에 대한 응답으로 렌더링 할 페이지 콘텐츠의 전체 HTML을 서버에서 생성합니다.
- SSR에서는 데이터 연결 및 fetching 작업이 서버에서 처리되기 때문에 SSR을 사용하면 데이터 fetching 및 템플릿 처리를 위한 추가적인 왕복시간을 줄일 수 없습니다.

### 특징

- SSR에서는 모든 요청이 독립적으로 처리되고, 서버에 의해 새로운 요청으로 간주됩니다.
- 연속된 두 요청의 결과각 크게 다르지 않더라도, 서버는 처음부터 다시 처리하고 HTML을 생성합니다.
- 서버의 데이터 처리 능력은 모든 사용자가 공유하게 됩니다. (서버는 모든 사용자가 공유하기 때문에) 

### 작동 방식

1. HTML을 서버에서 렌더링
2. 클라이언트에서 하이드레이션 (자바스크립트 코드 주입) - 최적화 필요

## 정적 렌더링 - 순수 정적 렌더링, 클라이언트 사이드 데이터 fetching

- 전체 페이지의 HTML을 빌드 시점에 미리 생성하며, 다음 빌드 때까지 변경되지 않습니다.
- 정적인 HTML 콘텐츠는 `CDN`이나 `엣지 네트워크`에 쉽게 캐싱될 수 있습니다.
- 순수 정적 렌더링은 요청 기반 데이터가 필요하지 않은 페이지에 가장 적합합니다.
- 클라이언트 사이드 데이터 fetching을 통한 정적 렌더링은 매 페이지 로드 시 새로고침되어야 하고 안정적인 placeholder 컴포넌트에 포함된 데이터가 있는 페이지에 가장 적합니다.

> ### CDN
> CDN은 클라이언트가 특정 페이지를 요청하면 미리 렌더링된 캐시된 HTML을 빠르게 제공할 수 있습니다.

## 정적 렌더링 - 점진적 정적 생성(ISR)

- 정적 렌더링과 SSR을 결합한 방식으로, 특정 정적 페이지만 미리 렌더링하고 동적 페이지는 사용자 요청 시에 on-demand 방식으로 렌더링합니다.
- 위의 방식을 통해 빌드 시간을 단축하며, 특정 시간 간격마다 캐시를 자도응로 무효화하고 페이지를 다시 생성할 수 있습니다.

### ISR의 점진적 업데이트

1. 새로운 페이지 추가 허용
    - 새로운 페이지는 첫 요청 즉시 생성합니다.
    - 생성되는 동안 프론트엔드에서 사용자에게 대체 페이지나 로딩 화면을 보여줄 수 있습니다.
2. 기존 페이지 업데이트
    - 각 페이지에 타임아웃을 정의하고, 시간이 경과할 때마다 페이지가 다시 유효한지 검증합니다.
    - 타임아웃은 `최소 1초`까지 설정할 수 있습니다.
    - 페이지 재검증 완료전까지 사용자는 이전 버전의 페이지를 보게 됩니다.
    - 이때 ISR은 `Stale-While-Revalidate` 전략을 사용합니다.

> ### Stale-While-Revalidate
> 캐시된 데이터를 먼저 보여주고, 동시에 백그라운드에서 새로운 데이터를 가져와 업데이트하는 전략이빈다. 이를 통해 사용자는 최신 데이터를 빠르게 확인할 수 있으며, 서버 부하를 줄일 수 있습니다.

## 정적 렌더링 - On-demand ISR

- 일반 ISR과 달리 `특정 이벤트 발생 시`에 페이지가 재생성됩니다.
- 일반 ISR에서는 해당 페이지에 대한 사용장자 요청을 처리한 엣지 네트워크 노드에만 캐시되는데, On-demand ISR은 엣지 네트워크 전체에 페이지를 다시 생성하고 재분배하므로, 자동으로 전 세계 사용자가 캐시된 오래된 콘텐츠가 아닌 최신 버전의 페이지를 볼 수 있습니다.
- 또한 불필요한 페이지 재생성과 서버리스 함수 호출을 피할 수 있어 일반 ISR에 비해 운영 비용을 절감할 수 있습니다.

> ### 서버리스 아키텍쳐란?
> 서버리스(serverless)란 개발자가 서버를 관리할 필요 없이 애플리케이션을 빌드하고 실행할 수 있도록 하는 클라우드 네이티브 개발 모델입니다. 서버리스 모델에도 서버가 존재하긴 하지만, 애플리케이션 개발에서와 달리 추상화되어 있습니다. 클라우드 제공업체가 서버 인프라에 대한 프로비저닝, 유지 관리, 스케일링 등의 일상적인 작업을 처리하며, 개발자는 배포를 위해 코드를 컨테이너에 패키징하기만 하면 됩니다.

## 스트리밍 SSR

- 스트리밍 방식(HTML 파일 하나를 생성하는 대신, 작은 조각(청크)로 나누어 전송하는 방식)으로 콘텐츠를 전송하여 애플리케이션을 서버에서 렌더링하면서도 TTI와 FCP를 더욱 단축하는 방법
- Node.js의 스트림 기능을 사용하면 응답 객체에 데이터를 스트리밍할 수 있는데, 이는 클라이언트에 데이터를 지속적으로 전송할 수 있음을 의미합니다.
- 클라이언트는 데이터 조각을 받는 즉시 콘텐츠 렌더링을 시작할 수 있습니다.

### 스트리밍과 네트워크

- 스트리밍은 네트워크 정체 현상에 매우 효과적입니다.
- 네트워크가 혼잡하여 더 이상 바이트를 전송할 수 없는 경우, 렌더러는 신호를 받아 해소 될때까지 스트리밍을 중단합니다.
- 따라서 서버는 메모리를 덜 사용하고 I/O가 필요한 상황에 더욱 민첩하게 반응할 수 있습니다.
- 이를 통해 서버는 여러 요청을 동시에 처리할 수 있으며, 무거운 요청이 가벼운 요청을 장시간 차단하는 것을 방지합니다.

### 리액트에서 지원하는 스트리밍

- ReactDOMServer.renderToNodeStream(element)
    - 이 함수는 서버에서만 THML을 스트리밍으로 렌더링합니다.
    - 이 스트리밍을 받는 클라이언트는 ReactDom.hydrate()를 호출하여 페이지를 하이드레이션하고, 상호작용이 가능하게 만들 수 있습니다.

- ReactDOMServer.renderToStaticNodeStream(element)
    - 서버에서 정적이고 비상호작용적인 페이지를 렌더링한 다음 클라이언트에 스트리밍하는 데 사용할 수 있습니다.


## 엣지 SSR

- 엣지 SSR은 CDN의 모든 지역에서 서버 렌더링을 가능하게 하고, 콜드 부트(함수가 처음 실행될 때 발생하는 지연 시간)을 거의 0에 가깝게 줄여줍니다.

### 엣지 SSR의 동작 방식

1. 서버리스 함수를 사용하여 전체 페이지를 서버 사이드에서 생성합니다.
2. 엣지 런타임은 HTTP 스트리밍도 지원하므로, 준비되는 즉시 문서의 일부를 스트리밍하고 각 컴포넌트를 세밀하게 하이드레이션하여 FCP 시간을 단축합니다.

## 하이브리드 렌더링

- 어떤 상황에서든 최적의 결과를 제공하기 위해 여러 가지 렌더링 방식을 결합하는 방법을 의미합니다.
- 정적으로 제공될 수 있는 페이지는 미리 렌더링되고, 애플리케이션의 다른 페이지에는 동적인 전략(예: ISR, SSr, SCR 및 후속 탐색을 위한 스트리밍)을 선택할 수 있습니다.

## 점진적 하이드레이션 

- 각 노드를 시간에 따라 개별적으로 하이드레이션하여 필요한 최소한의 자바스크립트만 요청하는 방식입니다.
- 페이지를 상호작용할 수 있게 만드는 데 필요한 자바스크립트 양을 줄이고, 사용자에게 필요한 노드만 하이드레이션할 수 있습니다. 
- 또한 점진적 하이드레이션은 SSR에서 흔히 발생하는 서버에서 렌더링된 DOM 트리가 파괴되고 즉시 다시 생성되는 문제를 방지할 수 있습니다.

### 주의사항

- 화면의 일부가 순차적으로 나타나면서 이미 로딩이완료된 부분의 상호작용이나 사용자 입력을 방해해서는 안 됩니다. 따라서 다음과 같은 사항을 고려하여야 합니다.

1. 모든 컴포넌트에 SSR 사용 가능
2. 개별 컴포넌트 또는 조각 단위로 코드 스플리팅 지원
3. 개발자가 정의한 순서대로 클라이언트 사이드에서 각 조각 별 하이드레이션 지원
4. 이미 하이드레이션 조각에서 사용자 입력 가능 상태 유지
5. 지연된 하이드레이션이 적용되는 조각에 로딩 중임을 표시 가능

### 동시성과 점진적 하이드레이션

- 리액트의 `동시성 모드` 기능이 도입되면 점진적 하이드레이션의 주의사항을 모두 충족할 수 있습니다.
- 동시성 모드는 점진적 하이드레이션을 구현하는 데에도 사용될 수 있으며 동시성 모드로 점진적 하이드레이션을 수현한다면 페이지의 각 조각을 하이드레이션 하는 작업을 동시성 모드가 맡게 됩니다.
- 사용자가 입력과 같은 더 높은 우선순위의 작업이 필요하면 리액트는 하이드레이션 작업을 일시 중지하고 사용자 입력을 받아들이는 작업으로 전환합니다.
- 여기에 `lazy()` 및 `Suspense()`와 같은 기능을 사용하면 선언적인 로딩 상태를 통해, 지연되는 중임을 보여줄 수 있습니다.
- 또한 `SuspenseList()`는 지연 로딩되는 컴포넌트의 우선순위를 정의하는데 사용할 수 있습니다.

> ### 동시성 모드
> 동시성 모드는 여러 작업을 동시에 처리하면서도 우선순위에 따라 작업 간 전환을 가능하게 합니다. 작업 전환 시 부분적으로 렌더링된 트리는 진행을 잠시 멈추어, 다시 동일한 작업으로 돌아왔을 때 이전의 렌더링 작업을 계속할 수 있습니다.


## 아일랜드 아키텍처

- 아일랜드 아키텍처는 정적인 HTML 위에 독립적으로 전달될 수 있는 상호작용 아일랜드를 통해 자바스크립트의 전송량을 줄이는 패러다임을 의미합니다.
- 정적 콘텐츠로 이루어진 페이지의 SSR을 지원하며, 이때 렌더링된 HTML에는 동적 콘텐츠를 위한 자리가 미리 마련되어 있습니다. 이 동적 콘텐츠 자리에는 자체적으로 완성된 컴포넌트 위젯이 들어가게 됩니다. 각 위젯은 독립적인 어플리케이션처럼 동작하며, 서버에서 렌더링된 결과물과 클라이언트 위젯을 활성화하는 데 사용될 자바스크립트 코드를 포함합니다.

### 아일랜드 아키텍처와 점진적 하이드레이션

|특징|아일랜드 아키텍처|점진적 하이드레이션|
|:---:|:---:|:---:|
|하이드레이션 구조| 상향식 | 하향식 |
|컴포넌트의 스케줄링 및 하이드레이션 제어 위치|각 컴포넌트|페이지|
|다른 컴포넌트에 영향| 다른 컴포넌트에 주지 않음 | 다른 컴포넌트에 영향을 줌 |

### 아일랜드 아키텍처 구현하기

아일랜드 아키텍처를 지원하는 프레임워크는 다음과 같은 기능을 제공해야 합니다.

- 자바스크립트 없이 서버에서 페이지를 정적으로 렌더링할 수 있어야 합니다.
- 정적 콘텐츠 내에 자리를 마련하여 독립적인 동적 컴포넌트를 포함할 수 있어야 합니다. 각 동적 컴포넌트는 자체 스크립트를 포함하며, 메인 스레드가 여유로워지는 즉시 requestIdlecallback()을 사용하여 스스로 하이드레이션할 수 있습니다.
- 서버에서 컴포넌트를 동형 렌더링하고 클라이언트에서 하이드레이션하여 서버와 클라이언트 양쪽에서 동일한 컴포넌트로 인식할 수 있습니다.

현재 아일랜드 아키텍처를 지원하는 프레임워크는 다음과 같습니다.

- Marko
- Astro
- Eveventy + Preact

### 아일랜드 아키텍처의 장점

1. 성능
    - 상호작용이 필요한 컴포넌트에만 스크립트가 전송되므로 클라이언트에 전송되는 코드의 양을 줄일 수 있습니다.
2. SEO
    - 모든 정적 콘텐츠가 서버에서 렌더링되므로 페이지는 SEO에 유리합니다.
3. 중요 콘텐츠 우선순위
    - 블로그, 뉴스 기사 및 제품 페이지ㅣ의 핵심 콘텐츠를 사용자가 즉시 볼 수 있습니다.
4. 접근성
    - 표준 정적 HTML 링크를 사용하여 다른 페이지에 접근하므로 웹사이트의 접근성이 향상됩니다.
5. 컴포넌트 기반
    - 재사용성과 유지보수 용이성과 같은 컴포넌트 기반 아키텍처의 모든 이점을 제공합니다.

### 아일랜드 아키텍처의 단점

- 기존 아키텍처를 현재 지원 중인 프레임워크로 마이그레이션 하는 단계가 필요합니다. 
- 수천 개의 아일랜드가 필요할 수 있느 소셜 미디어 어플리케이션과 같이 상호작용을 위주로 한 페이지에는 적합하지 않습니다.

## 리액트 서버 컴포넌트

- 리액트 서버 컴포넌트는 서버에서 실행되도록 설계된 상태를 가지지 않는 컴포넌트로, 서버 주도 방식으로 현대적인 사용자 경험을 제공하는 것을 목표로 합니다.
- 이러한 컴포넌트들을 번들 크기를 0으로 줄이고, 서버 컴포넌트와 클라이언트 컴포넌트 사이의 매끄러운 코드 전환 경험 `니팅`을 가능하게 합니다.

### 리액트 서버 컴포넌트의 동작 

- 최상위 레벨에서 await를 사용해 서버 사이드 데이터 직렬화를 가능하게 합니다.
- 컴포넌트는 데이터를 정기적으로 다시 가져올 수 있으며, 새로운 데이터가 있을 때 다시 렌더링되는 컴포넌트를 가진 애플리케이션을 서버에서 실행할 수 있어 클라이언트로 전송해야하는 코드 양을 줄일 수 있습니다.

### 특징

- 서버는 클라이언트가 컴포넌트 트리의 일부를 요청할 수 있는 특별한 엔드포인트를 제공하여 MPA와 유사한 아키텍처로 SPA와 같은 라우팅을 가능하게 합니다.
- 이를 통해 상태의 변경 없이 서버 컴포넌트 트리와 클라이언트 사이드 트리를 병합하고 더 많은 컴포넌트로 확장할 수 있습니다.

### RSC와 Next.js의 App Router

- Next.js App Router는 서버 렌더링과 클라이언트 사이드 상호작용을 결합하여 점진적으로 애플리케이션을 향상시키고 매끄러운 사용자 경험을 제공합니다.
- Next.js에서 클라이언트 컴포넌트느 'use client' 지시문을 사용하여 컴포넌트를 클라이언트로 선언할 수 있습니다. 'use client' 지시문이 없는 컴포넌트는 다른 클라이언트에 의해 import 되지 않는 한 자동으로 서버 컴포넌트로 렌더링됩니다.
- Nest.js에서 서버 컴포넌트와 클라이언트 컴포넌트는 동일한 컴포넌트 트리 내에 혼합되어 사용될 수 있으며, 리액트는 두 환경의 병합을 처리합니다.